# ğŸ“Œ **Getting Structured & Consistent Outputs from Tasks**  

In **AI-powered automation**, ensuring that **task outputs are structured and validated** is crucial. This prevents errors, ensures data consistency, and allows smooth integration with other systems.  

ğŸš€ **CrewAI** provides a feature called `output_pydantic`, which allows us to define **structured outputs** using **Pydantic models**.  

âœ” **Why use structured outputs?**  
- âœ… **Consistency** â€“ Ensures that all outputs follow a predefined format.  
- âœ… **Validation** â€“ Prevents missing or incorrect data.  
- âœ… **Reliability** â€“ Helps in seamless integration with other applications.  

---

# ğŸ—ï¸ **How Task Output Works in CrewAI**  

- In **CrewAI**, the **final task's output** becomes the **final output of the crew**.  
- By using **Pydantic models**, we ensure that this output follows a strict format.  

---

# ğŸ“Œ **Real-World Example: AI-Generated Blog Content**  

Imagine you're building an **AI-powered blogging assistant** that generates blog titles and content.  

### Problem:  
âŒ AI sometimes returns **unstructured, inconsistent outputs**.  
âŒ Some outputs **miss important fields** (e.g., no title).  
âŒ Itâ€™s hard to **process AI-generated content programmatically**.  

### Solution:  
âœ… We use **Pydantic models** to ensure a **structured response**.  
âœ… This guarantees that **every blog has a title and content**.  
âœ… It makes it easy to **store, analyze, and integrate the output**.  

---

# ğŸ–¥ **Example Code: Structured AI Task Output Using CrewAI & Pydantic**  

```python
import json
from crewai import Agent, Crew, Process, Task
from pydantic import BaseModel

# ğŸ— Define a Pydantic model for the expected output
class Blog(BaseModel):
    title: str  # âœ… Title of the blog
    content: str  # âœ… Content of the blog

# ğŸ­ Define the AI agent responsible for content generation
blog_agent = Agent(
    role="Blog Content Generator Agent",
    goal="Generate a blog title and content",
    backstory="You are an expert content creator, skilled in crafting engaging and informative blog posts.",
    verbose=False,
    allow_delegation=False,
    llm="gpt-4o",
)

# ğŸ“ Define a task for the agent
task1 = Task(
    description="Create a blog title and content on a given topic. Make sure the content is under 200 words.",
    expected_output="A compelling blog title and well-written content.",
    agent=blog_agent,
    output_pydantic=Blog,  # ğŸ”„ Ensure the output follows the Blog Pydantic model
)

# ğŸ¢ Create a Crew and assign tasks to the agent
crew = Crew(
    agents=[blog_agent],
    tasks=[task1],
    verbose=True,
    process=Process.sequential,  # ğŸ”„ Tasks are executed sequentially
)

# ğŸš€ Execute the CrewAI workflow
result = crew.kickoff()

# ğŸ“Œ Accessing the output in multiple ways:

# âœ… Option 1: Dictionary-style indexing
print("Accessing Properties - Option 1")
title = result["title"]
content = result["content"]
print("Title:", title)
print("Content:", content)

# âœ… Option 2: Accessing from Pydantic model
print("Accessing Properties - Option 2")
title = result.pydantic.title
content = result.pydantic.content
print("Title:", title)
print("Content:", content)

# âœ… Option 3: Converting to dictionary
print("Accessing Properties - Option 3")
output_dict = result.to_dict()
title = output_dict["title"]
content = output_dict["content"]
print("Title:", title)
print("Content:", content)

# âœ… Option 4: Printing the entire blog object
print("Accessing Properties - Option 4")
print("Blog:", result)
```

---

# ğŸ“Œ **Breaking Down the Code**  

### ğŸ¯ **Step 1: Define a Pydantic Model**  
```python
class Blog(BaseModel):
    title: str
    content: str
```
- `BaseModel`: Inherits from Pydantic's base class.  
- `title: str`: Ensures that every blog **must have a title**.  
- `content: str`: Ensures that the blog **must have content**.  
- If AI **fails to generate** a title or content, it will throw a **validation error**.  

---

### ğŸ¯ **Step 2: Create an AI Agent**  
```python
blog_agent = Agent(
    role="Blog Content Generator Agent",
    goal="Generate a blog title and content",
    backstory="You are an expert content creator, skilled in crafting engaging and informative blog posts.",
    verbose=False,
    allow_delegation=False,
    llm="gpt-4o",
)
```
- **Defines an AI agent** specialized in writing blogs.  
- **Goal:** Generates blog titles and content.  
- **Uses GPT-4o** as its language model.  

---

### ğŸ¯ **Step 3: Define the AI Task**  
```python
task1 = Task(
    description="Create a blog title and content on a given topic. Make sure the content is under 200 words.",
    expected_output="A compelling blog title and well-written content.",
    agent=blog_agent,
    output_pydantic=Blog,  # âœ… Enforces structured output
)
```
- The **task** asks AI to generate a **blog title and content**.  
- The `output_pydantic=Blog` ensures that the output **matches the Blog model**.  

---

### ğŸ¯ **Step 4: Create a Crew and Assign the Task**  
```python
crew = Crew(
    agents=[blog_agent],
    tasks=[task1],
    verbose=True,
    process=Process.sequential,  # ğŸ”„ Ensures tasks run one after another
)
```
- Creates a **CrewAI workflow** with **one agent and one task**.  
- **Sequential processing** ensures tasks execute in order.  

---

### ğŸ¯ **Step 5: Run the AI Task and Get Results**  
```python
result = crew.kickoff()
```
- This **runs the task**, and AI generates a **blog title and content**.  

---

# ğŸ“Œ **How to Access the Output?**  

Once the task is executed, the **result is stored in a structured format**. You can access it in **multiple ways**:  

âœ… **Option 1: Dictionary-style indexing**  
```python
title = result["title"]
content = result["content"]
```
- Allows **direct access** like a dictionary.  

âœ… **Option 2: Accessing from Pydantic model**  
```python
title = result.pydantic.title
content = result.pydantic.content
```
- Uses **Pydanticâ€™s model** for cleaner attribute access.  

âœ… **Option 3: Converting to dictionary**  
```python
output_dict = result.to_dict()
title = output_dict["title"]
content = output_dict["content"]
```
- Converts the **Pydantic object** into a dictionary.  

âœ… **Option 4: Printing the entire object**  
```python
print("Blog:", result)
```
- Prints the **structured blog object**.  

---

# ğŸ¯ **Key Takeaways**  

âœ… **Ensures structured, validated AI output** using `output_pydantic`  
âœ… **Prevents missing or malformed data**  
âœ… **Easier integration** into other applications  
âœ… **Multiple ways to access results**  

Would you like to extend this with **error handling or dynamic topics**? ğŸš€