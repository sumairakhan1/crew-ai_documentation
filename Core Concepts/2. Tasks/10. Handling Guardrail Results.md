# ğŸ›¡ï¸ **Handling Guardrail Results in AI and Automation**  

When working with **AI models** or **automated systems**, **guardrails** act as **filters** to ensure the generated output is **valid and correct**.  

For example, if you're using **AI to generate JSON reports**, a guardrail can:  
âœ” Check if the JSON is **well-formed**.  
âœ” Return **errors** if itâ€™s **incorrect**.  
âœ” **Retry** fixing the issue until it's **correct**.  

---

# ğŸ¯ **Why Do We Need Guardrails?**  

ğŸš€ **Ensures AI-generated output is reliable**  
ğŸ”„ **Automatically retries fixing errors**  
ğŸ” **Improves data quality and system performance**  
ğŸ›‘ **Prevents incorrect or harmful outputs**  

---

# ğŸ“Œ **Real-World Use Case: AI-Generated Reports**  

Imagine youâ€™re building an **AI-powered financial dashboard** that generates daily reports in **JSON format**.  

### Problem:  
âŒ Sometimes, the AI **fails to generate valid JSON** due to missing or malformed data.  

### Solution:  
âœ… We use a **guardrail function** to **validate the JSON output** and **retry until itâ€™s correct**.  

---

# ğŸ”„ **How the Guardrail Works**  

1ï¸âƒ£ The **guardrail function** checks if the output is **valid**.  
2ï¸âƒ£ If **invalid**, it returns `(False, error)` and sends it back to the agent.  
3ï¸âƒ£ The **agent** tries to **fix the issue** and retries.  
4ï¸âƒ£ This process **repeats until**:  
   âœ” The **output is valid** `(True, result)`.  
   âŒ The **maximum retries** are reached.  

---

# ğŸ–¥ **Example Code: Guardrail with Retry Handling**  

```python
import json
from typing import Any, Dict, Tuple, Union

def validate_json_output(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:
    """Validate and parse JSON output."""
    try:
        # ğŸ›  Attempt to parse the string as JSON
        data = json.loads(result)
        return (True, data)  # âœ… Success: Return parsed JSON
    except json.JSONDecodeError as e:
        return (False, {
            "error": "Invalid JSON format",  # âŒ Error message
            "code": "JSON_ERROR",  # ğŸ”¢ Error code
            "context": {"line": e.lineno, "column": e.colno}  # ğŸ” Error location
        })

class Task:
    def __init__(self, description, expected_output, agent, guardrail, max_retries=3):
        self.description = description
        self.expected_output = expected_output
        self.agent = agent
        self.guardrail = guardrail
        self.max_retries = max_retries

    def execute(self):
        retries = 0
        while retries < self.max_retries:
            output = self.agent.generate_output()  # ğŸ”„ AI generates output
            is_valid, result = self.guardrail(output)  # ğŸ›¡ï¸ Validate output

            if is_valid:
                return result  # âœ… Return valid output
            
            print(f"Retry {retries + 1}: {result}")  # âš ï¸ Log the error
            
            retries += 1
        
        return {"error": "Max retries reached", "code": "MAX_RETRIES"}

# Example agent class (simulated AI system)
class Agent:
    def generate_output(self):
        # Simulating an AI response (sometimes incorrect JSON)
        return '{"name": "John Doe", "age": 30'  # âŒ Missing closing bracket

# Initialize agent and task
analyst = Agent()
task = Task(
    description="Generate a JSON report",
    expected_output="A valid JSON object",
    agent=analyst,
    guardrail=validate_json_output,
    max_retries=3
)

# Execute the task with guardrails
result = task.execute()
print(result)
```

---

# ğŸ“Œ **Breaking Down the Code**  

### ğŸ“ **Step 1: JSON Validation Function**  
```python
def validate_json_output(result: str) -> Tuple[bool, Union[Dict[str, Any], str]]:
```
- Takes **one input** (`result`) â†’ a JSON **string**.  
- Returns **(True, JSON object)** if valid.  
- Returns **(False, error details)** if invalid.  

---

### ğŸ“ **Step 2: Attempt to Parse JSON**  
```python
data = json.loads(result)
return (True, data)
```
- Uses `json.loads(result)` to **convert a string into a JSON object**.  
- If **successful**, returns the parsed **JSON data**.  

---

### ğŸ“ **Step 3: Handling JSON Errors**  
```python
except json.JSONDecodeError as e:
    return (False, {
        "error": "Invalid JSON format",
        "code": "JSON_ERROR",
        "context": {"line": e.lineno, "column": e.colno}
    })
```
- If JSON is **malformed**, it:  
  âœ” Returns an **error message** `"Invalid JSON format"`.  
  âœ” Includes an **error code** `"JSON_ERROR"`.  
  âœ” Provides **context** (`line` and `column` where the error occurred).  

---

### ğŸ“ **Step 4: Task Class (Handles Retries)**  
```python
class Task:
    def __init__(self, description, expected_output, agent, guardrail, max_retries=3):
```
- Stores **task details**, the **agent**, and the **guardrail function**.  
- Sets **maximum retry attempts** (`max_retries`).  

---

### ğŸ“ **Step 5: Executing the Task with Guardrails**  
```python
while retries < self.max_retries:
    output = self.agent.generate_output()  # ğŸ”„ AI generates output
    is_valid, result = self.guardrail(output)  # ğŸ›¡ï¸ Validate output

    if is_valid:
        return result  # âœ… Return valid output

    print(f"Retry {retries + 1}: {result}")  # âš ï¸ Log the error
    
    retries += 1

return {"error": "Max retries reached", "code": "MAX_RETRIES"}
```
- **Loops through retries** (max **3 attempts**).  
- If **valid output**, returns it.  
- If **invalid**, retries **until itâ€™s correct or reaches max retries**.  

---

# ğŸ¯ **Key Takeaways**  

âœ… **Guardrails ensure AI-generated output is valid**  
âœ… **If errors occur, the system retries fixing them**  
âœ… **Provides structured error responses** for debugging  
âœ… **Improves automation reliability**  

Would you like me to **add logging or improve retry logic?** ğŸš€